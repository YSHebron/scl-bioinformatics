use strict;
use IO::Handle;
use List::Util 'shuffle';
use List::Util 'max';
use POSIX;
use Storable qw(dclone);
use Getopt::Std;

# inputs:
# -c <CMC clusters basefilename>
# -1 <clusterone clusters basefilename>
# -i <IPCA clusters basefilename>
# -m <MCL clusters basefilename>
# -r <RNSC clusters basefilename>
# -h <HACO clusters basefilename>
# -a <Coach clusters basefilename>
# -n <num iters>
# -t <Match threshold for duplicate clusters>
# -e <multiple clusters from the same source that get grouped together only contribute to the score ONCE. Default 1>
# -s <remove small clusters? Default 0>
# -o <Output basefilename>
# Eg. perl combine_cluster_results -c "clusters_cmc stringdata10k xval_.8_.2" 
# 																	-1 "clusters_clusterone stringdata10k xval_.8_.2"
#																		-i "clusters_ipca stringdata10k xval_.8_.2" 
#																		-m "clusters_mcl stringdata10k xval_.8_.2" 
#																		-r "clusters_rnsc stringdata10k xval_.8_.2" 
#																		-h "clusters_haco stringdata10k xval_.8_.2" 
#																		-n 25
#																		-t .75
#																		"clusters_combined.75 stringdata10k xval_.8_.2"


my %argopts;
if (! getopts('c:1:i:m:r:h:a:n:t:e:s:o:', \%argopts)) { die "invalid arguments"; }

my $REMOVE_SMALL_CLUS = 0;
if (defined $argopts{'s'}) {
	$REMOVE_SMALL_CLUS = 1;
}

my $num_cluster_sources = 0;
my $cmcbasefilename = "";
my $c1basefilename = "";
my $ipcabasefilename = "";
my $mclbasefilename = "";
my $rnscbasefilename = "";
my $hacobasefilename = "";
my $coachbasefilename = "";
if (defined $argopts{'c'}) {
	$cmcbasefilename = $argopts{'c'};
	$num_cluster_sources++;
}
if (defined $argopts{'1'}) {
	$c1basefilename = $argopts{'1'};
	$num_cluster_sources++;
}
if (defined $argopts{'i'}) {
	$ipcabasefilename = $argopts{'i'};
	$num_cluster_sources++;
}
if (defined $argopts{'m'}) {
	$mclbasefilename = $argopts{'m'};
	$num_cluster_sources++;
}
if (defined $argopts{'r'}) {
	$rnscbasefilename = $argopts{'r'};
	$num_cluster_sources++;
}
if (defined $argopts{'h'}) {
	$hacobasefilename = $argopts{'h'};
	$num_cluster_sources++;
}
if (defined $argopts{'a'}) {
	$coachbasefilename = $argopts{'a'};
	$num_cluster_sources++;
}
my $numiters = 1;
if (defined $argopts{'n'}) {
	$numiters = $argopts{'n'} +0;
}
my $matchscore_thr = $argopts{'t'} + 0;
my $outputbasefilename = $argopts{'o'};
my $contributeonce = 1;
if (defined $argopts{'e'}) {
	$contributeonce = $argopts{'e'} + 0;
}


my %cmcclusters; # $clusters{$iter}{$c}{SCORE} = score, $clusters{$iter}{$c}{ELEMENTS}{$pid} = 1
my %c1clusters;
my %ipcaclusters;
my %mclclusters;
my %rnscclusters;
my %hacoclusters;
my %coachclusters;
my %combinedclusters;
ReadClusters($cmcbasefilename, \%cmcclusters, $numiters, "CMC"); 		AnalyzeClusters(\%cmcclusters, $numiters, "CMC");
ReadClusters($c1basefilename, \%c1clusters, $numiters, "CL1"); 		AnalyzeClusters(\%c1clusters, $numiters, "CL1");
ReadClusters($ipcabasefilename, \%ipcaclusters, $numiters, "IPCA");	AnalyzeClusters(\%ipcaclusters, $numiters, "IPCA");
ReadClusters($mclbasefilename, \%mclclusters, $numiters, "MCL");		AnalyzeClusters(\%mclclusters, $numiters, "MCL");
ReadClusters($rnscbasefilename, \%rnscclusters, $numiters, "RNSC");	AnalyzeClusters(\%rnscclusters, $numiters, "RNSC");
ReadClusters($hacobasefilename, \%hacoclusters, $numiters, "HACO");	AnalyzeClusters(\%hacoclusters, $numiters, "HACO");
ReadClusters($coachbasefilename, \%coachclusters, $numiters, "COACH");	AnalyzeClusters(\%coachclusters, $numiters, "COACH");

print "Num cluster sources = $num_cluster_sources\n";


if ($matchscore_thr < 1) {
	print "Matchscore threshold = $matchscore_thr < 1, so removing duplicates from individual sources first\n";
	for (my $iter = 0; $iter < $numiters; $iter++) {
		RemoveDuplicateClusters(\%{$cmcclusters{$iter}}, $matchscore_thr);
		RemoveDuplicateClusters(\%{$c1clusters{$iter}}, $matchscore_thr);
		RemoveDuplicateClusters(\%{$ipcaclusters{$iter}}, $matchscore_thr);
		RemoveDuplicateClusters(\%{$mclclusters{$iter}}, $matchscore_thr);
		RemoveDuplicateClusters(\%{$rnscclusters{$iter}}, $matchscore_thr);
		RemoveDuplicateClusters(\%{$hacoclusters{$iter}}, $matchscore_thr);
		RemoveDuplicateClusters(\%{$coachclusters{$iter}}, $matchscore_thr);
	}
	AnalyzeClusters(\%cmcclusters, $numiters, "CMC");
	AnalyzeClusters(\%c1clusters, $numiters, "CL1");
	AnalyzeClusters(\%ipcaclusters, $numiters, "IPCA");
	AnalyzeClusters(\%mclclusters, $numiters, "MCL");
	AnalyzeClusters(\%rnscclusters, $numiters, "RNSC");
	AnalyzeClusters(\%hacoclusters, $numiters, "HACO");
	AnalyzeClusters(\%coachclusters, $numiters, "COACH");
}
print "\n";


my %clusters_overlap_info = (); # $clusters_overlap_info{$iter}{6} = # clusters generated by all 6 methods, {4} = generated by 4 methods, etc, {CMC} = num clusters uniquely from CMC, etc
for (my $iter = 0; $iter < $numiters; $iter++) {
	$combinedclusters{$iter} = ();
	CombineClusters ($cmcclusters{$iter}, $c1clusters{$iter}, $ipcaclusters{$iter}, $mclclusters{$iter}, $rnscclusters{$iter}, $hacoclusters{$iter}, $coachclusters{$iter}, \%{$combinedclusters{$iter}});
	print "iteration $iter: ".(scalar keys %{$cmcclusters{$iter}})." cmc clusters, ".(scalar keys %{$c1clusters{$iter}})." clusterone clusters, ".(scalar keys %{$ipcaclusters{$iter}})." ipca clusters, ".(scalar keys %{$mclclusters{$iter}})." mcl clusters, ".(scalar keys %{$rnscclusters{$iter}})." rnsc clusters, ".(scalar keys %{$hacoclusters{$iter}})." haco clusters, ".(scalar keys %{$coachclusters{$iter}})." coach clusters, ".(scalar keys %{$combinedclusters{$iter}})." combined clusters\n";
	$clusters_overlap_info{$iter} = ();
	RemoveDuplicateClustersAnalyze(\%{$combinedclusters{$iter}}, $matchscore_thr, \%{$clusters_overlap_info{$iter}}, $contributeonce);
	print "removed duplicates, ".(scalar keys %{$combinedclusters{$iter}})." combined clusters\n";
	print "Overlapping clusters info:\n";
	foreach my $src (sort keys %{$clusters_overlap_info{$iter}}) {
		print "$src\t$clusters_overlap_info{$iter}{$src}\n";
	}
	print "\n";
	
	# normalize scores by number of cluster sources
	foreach my $clus (keys  %{$combinedclusters{$iter}}) {
		$combinedclusters{$iter}{$clus}{SCORE} /= $num_cluster_sources;
	}
	
	# print
	if ($numiters > 1) {
		open (OUTPUTFILE, ">$outputbasefilename iter".$iter.".txt") || die $!;
	}
	else {
		open (OUTPUTFILE, ">$outputbasefilename") || die $!;
	}
	foreach my $clus (sort {$combinedclusters{$iter}{$b}{SCORE} <=> $combinedclusters{$iter}{$a}{SCORE}} keys %{$combinedclusters{$iter}}) {
		my @prots = sort keys %{$combinedclusters{$iter}{$clus}{ELEMENTS}};
		my $protsstring = join (" ", @prots);
		my $size = scalar @prots;
		my @srcs = split(/\|/, $combinedclusters{$iter}{$clus}{SRC});
		my $num_srcs = scalar @srcs;
		my $srcs_str = "|$num_srcs|".$combinedclusters{$iter}{$clus}{SRC}."|";
#		if ($size < 4) { next; }
		print OUTPUTFILE "C$clus$srcs_str(".$size."_$combinedclusters{$iter}{$clus}{SCORE}): $protsstring\n";
	}	
	close OUTPUTFILE;

}

# Analyze and print characteristics of combined clusters
print "-------- Combined clusters characteristics: --------\n";
AnalyzeClusters(\%combinedclusters, $numiters, "COMBINED");
print "\n";


my %clusters_overlap_info_alliters = (); # $clusters_overlap_info_alliters{5}{MEAN} = mean # clusters generated by all 5 methods across all iters, etc., {STD} = std
for (my $iter = 0; $iter < $numiters; $iter++) {
	foreach my $src (keys %{$clusters_overlap_info{$iter}}) {
		$clusters_overlap_info_alliters{$src}{MEAN} += $clusters_overlap_info{$iter}{$src};
		$clusters_overlap_info_alliters{$src}{STD} += ($clusters_overlap_info{$iter}{$src}) ** 2;
	}
}
foreach my $src (keys %clusters_overlap_info_alliters) {
	$clusters_overlap_info_alliters{$src}{MEAN} /= $numiters;
	$clusters_overlap_info_alliters{$src}{STD} /= $numiters;
	$clusters_overlap_info_alliters{$src}{STD} = $clusters_overlap_info_alliters{$src}{STD} - $clusters_overlap_info_alliters{$src}{MEAN} ** 2;
	$clusters_overlap_info_alliters{$src}{STD} = $clusters_overlap_info_alliters{$src}{STD} ** .5;
}
	
print "NumSrcs\tMean\tStd\n";
foreach my $src (sort keys %clusters_overlap_info_alliters) {
	print "$src\t$clusters_overlap_info_alliters{$src}{MEAN}\t$clusters_overlap_info_alliters{$src}{STD}\n";
}




# ------------------------------------------------------------


sub MatchClusters ($$) {
	my $clus1_ref = $_[0];
	my $clus2_ref = $_[1];
	
	if (scalar keys %{$clus1_ref} < scalar keys %{$clus2_ref}) {
		my $tmp = $clus1_ref;
		$clus1_ref = $clus2_ref;
		$clus2_ref = $tmp;
	}
	
	# for speed, clus1 should be the bigger cluster
	my $num_intersect = 0;
	foreach my $elem (keys %$clus2_ref) {
		if (defined $$clus1_ref{$elem}) {
			$num_intersect++;
		}
	}
	my $num_union = (scalar keys %{$clus1_ref}) + (scalar keys %{$clus2_ref}) - $num_intersect;
	return ($num_intersect/$num_union);
}


# match cluster with a lower bound. If match score is definitely below lower bound, then just return 0, no need to compute exactly
sub MatchClustersLB ($$$) {
	my $clus1_ref = $_[0];
	my $clus2_ref = $_[1];
	my $lowerbound = $_[2];
	
	if (scalar keys %{$clus1_ref} < scalar keys %{$clus2_ref}) {
		my $tmp = $clus1_ref;
		$clus1_ref = $clus2_ref;
		$clus2_ref = $tmp;
	}
	
	if ((scalar keys %{$clus2_ref}) / (scalar keys %{$clus1_ref}) < $lowerbound) { 
		return 0;
	}
	
	# for speed, clus1 should be the bigger cluster
	my $num_intersect = 0;
	foreach my $elem (keys %$clus2_ref) {
		if (defined $$clus1_ref{$elem}) {
			$num_intersect++;
		}
	}
	my $num_union = (scalar keys %{$clus1_ref}) + (scalar keys %{$clus2_ref}) - $num_intersect;
	return ($num_intersect/$num_union);
}




sub AnalyzeClusters {
	my $clusters_ref = $_[0];
	my $numiters = $_[1];
	my $clustersource = $_[2];
	
	if (scalar keys %{$clusters_ref}==0) { return; }
	
	my $numclus = 0;
	my $sizemean = 0;
	my $sizestd = 0;
	for (my $iter=0; $iter<$numiters; $iter++) {		
		foreach my $clus (keys %{$$clusters_ref{$iter}}) {
			$numclus++;
			$sizemean += scalar keys %{$$clusters_ref{$iter}{$clus}{ELEMENTS}};
			$sizestd += (scalar keys %{$$clusters_ref{$iter}{$clus}{ELEMENTS}})**2;				
		}
	}
	if ($numclus==0) { return; }
	$sizemean /= $numclus;
	$sizestd /= $numclus;
	$sizestd = $sizestd - $sizemean**2;
	$sizestd = $sizestd ** .5;
	print "$clustersource: num clusters = $numclus, size mean = $sizemean, size std = $sizestd\n";
}

 
# $clusters{$iter}{$c}{SCORE} = score, $clusters{$iter}{$c}{SRC} = "CMC" or "IPCA" etc, $clusters{$iter}{$c}{ELEMENTS}{$pid} = 1
sub ReadClusters ($$$) {
	my $filename = $_[0];
	my $clusters_ref = $_[1];
	my $numiters = $_[2];
	my $clustersource = $_[3];
	
	if ($numiters>1) {
		for (my $iter=0; $iter<$numiters; $iter++) {		
			%{$$clusters_ref{$iter}} = ();
			if ($filename eq "") {
				next;
			}
			open (CLUSTERS_FILE, "$filename iter".$iter.".txt") || die ("$filename iter".$iter.".txt");
			foreach my $line (<CLUSTERS_FILE>) {
				chomp($line);
				my @toks = split(' ', $line);
				(my $clus, my $rest) = split(/\(/, $toks[0]);
				(my $rest2, my $score) = split("_", $rest);
				$score = substr($score, 0, length($score)-2);
				$clus = ($clustersource."_".$clus);
				$$clusters_ref{$iter}{$clus}{SCORE} = $score + 0;
				$$clusters_ref{$iter}{$clus}{SRC} = $clustersource;
				shift @toks;
				foreach (@toks) {
					$$clusters_ref{$iter}{$clus}{ELEMENTS}{$_} = 1;
				}
				if ($REMOVE_SMALL_CLUS==1) {
					if (scalar keys %{$$clusters_ref{$iter}{$clus}{ELEMENTS}} <= 3) {
						delete $$clusters_ref{$iter}{$clus};
					}
				}
			}			
			close CLUSTERS_FILE;
		}
	}
	else {
		my $iter = 0;	
		%{$$clusters_ref{$iter}} = ();
		if ($filename eq "") {
			return;
		}
		open (CLUSTERS_FILE, "$filename") || die ("$filename");
		foreach my $line (<CLUSTERS_FILE>) {
			chomp($line);
			my @toks = split(' ', $line);
			(my $clus, my $rest) = split(/\(/, $toks[0]);
			(my $rest2, my $score) = split("_", $rest);
			$score = substr($score, 0, length($score)-2);
			$clus = ($clustersource."_".$clus);
			$$clusters_ref{$iter}{$clus}{SCORE} = $score + 0;
			$$clusters_ref{$iter}{$clus}{SRC} = $clustersource;
			shift @toks;
			foreach (@toks) {
				$$clusters_ref{$iter}{$clus}{ELEMENTS}{$_} = 1;
			}
			if ($REMOVE_SMALL_CLUS==1) {
				if (scalar keys %{$$clusters_ref{$iter}{$clus}{ELEMENTS}} <= 3) {
					delete $$clusters_ref{$iter}{$clus};
				}
			}
		}			
		close CLUSTERS_FILE;		
	}

}


sub RemoveDuplicateClusters ($$) {
	my $clusters_ref = $_[0];
	my $match_thres = $_[1];
	
	my @clusters = sort {$$clusters_ref{$b}{SCORE} <=> $$clusters_ref{$a}{SCORE}} keys %$clusters_ref;
	my %clusters_to_delete = ();
	
	for (my $idx1 = 0; $idx1 < scalar @clusters; $idx1++) {
		for (my $idx2 = $idx1+1; $idx2 < scalar @clusters; $idx2++) {
			my $clus1 = $clusters[$idx1];
			my $clus2 = $clusters[$idx2];
			if (defined $clusters_to_delete{$clus1} && $clusters_to_delete{$clus1}==1) { next; }
			if (defined $clusters_to_delete{$clus2} && $clusters_to_delete{$clus2}==1) { next; }
			my $matchscore = MatchClustersLB($$clusters_ref{$clus1}{ELEMENTS}, $$clusters_ref{$clus2}{ELEMENTS}, $match_thres);
			if ($matchscore >= $match_thres) {
				$clusters_to_delete{$clus2} = 1;
#				$$clusters_ref{$clus1}{SCORE} += $$clusters_ref{$clus2}{SCORE};
			}
		}
	}
		
	print "In RemoveDuplicateClusters, num to delete = ".(scalar keys %clusters_to_delete)."\n";
	
	foreach my $clus (keys %clusters_to_delete) {
		delete $$clusters_ref{$clus};
	}	
}



sub RemoveDuplicateClustersAnalyze ($$) {
	my $clusters_ref = $_[0];
	my $match_thres = $_[1];
	my $clusters_overlap_info_ref = $_[2];
	my $contributeonce = $_[3];
	
	my @clusters = sort {$$clusters_ref{$b}{SCORE} <=> $$clusters_ref{$a}{SCORE}} keys %$clusters_ref;
	my %clusters_to_delete = (); # $clusters_to_delete{$clus1}{$clus2} = 1, if $clus1 is deleted because it matches with $clus2 and $clus2 is higher score
	my %clusters_representatives = (); # $clusters_representatives{$clus2}{$clus1} = 1, if $clus2 is a cluster representative and $clus1 is deleted because of $clus2
	
	for (my $idx1 = 0; $idx1 < scalar @clusters; $idx1++) {
		for (my $idx2 = $idx1+1; $idx2 < scalar @clusters; $idx2++) {
			my $clus1 = $clusters[$idx1];
			my $clus2 = $clusters[$idx2];
			if (defined $clusters_to_delete{$clus1} && scalar keys %{$clusters_to_delete{$clus1}}>0) { next; }
			if (defined $clusters_to_delete{$clus2} && scalar keys %{$clusters_to_delete{$clus2}}>0) { next; }
			my $matchscore = MatchClustersLB($$clusters_ref{$clus1}{ELEMENTS}, $$clusters_ref{$clus2}{ELEMENTS}, $match_thres);
			if ($matchscore >= $match_thres) {
				$clusters_to_delete{$clus2}{$clus1} = 1;
				$clusters_representatives{$clus1}{$clus2} = 1;
				if ($contributeonce==0) {
					$$clusters_ref{$clus1}{SCORE} += $$clusters_ref{$clus2}{SCORE};
				}
				else {
					my $contribute_score = 1;
					foreach my $clus (keys %{$clusters_representatives{$clus1}}) {
						if ($clus eq $clus2) { next; }
						if ($$clusters_ref{$clus}{SRC} eq $$clusters_ref{$clus2}{SRC}) {
							$contribute_score = 0;
							last;
						}
					}
					if ($contribute_score==1) {
						$$clusters_ref{$clus1}{SCORE} += $$clusters_ref{$clus2}{SCORE};
					}	
				}
			}
		}
	}
	
	# add clusters that are not deleted, and do not represent other clusters, to %clusters_representatives
	foreach my $clus (@clusters) {
		if (!defined $clusters_to_delete{$clus} && !defined $clusters_representatives{$clus}) {
			$clusters_representatives{$clus} = ();
		}
	}
	
	# do some checks
	#if ((scalar keys %clusters_to_delete) + (scalar keys %clusters_representatives) != scalar @clusters) { die; }
#	my $num_clusters = 0;
#	foreach my $clus (keys %clusters_representatives) {
#		$num_clusters++;
#		$num_clusters += (scalar keys %{$clusters_representatives{$clus}});
#		foreach my $clus_del (keys %{$clusters_representatives{$clus}}) {
#			if (!defined $clusters_to_delete{$clus_del}) { die; }
#			if (!defined $clusters_to_delete{$clus_del}{$clus}) { die; }
#		}
#	}
#	if ($num_clusters != scalar @clusters) { die; }
	
	
	# do some checks
	my %clusters_check = ();
	foreach my $clus (keys %clusters_representatives) {
		$clusters_check{$clus} = 1;
		foreach my $clus_del (keys %{$clusters_representatives{$clus}}) {
			if (!defined $clusters_to_delete{$clus_del}) { die; }
			if (!defined $clusters_to_delete{$clus_del}{$clus}) { die; }
			$clusters_check{$clus_del} = 1;
		}
	}
	if (scalar keys %clusters_check != scalar @clusters) { die; }
	
	# set the clusters' sources and print some info	
	print "In RemoveDuplicateClustersAnalyze, num to delete = ".(scalar keys %clusters_to_delete).", num representatives = ".(scalar keys %clusters_representatives)."\n";
#	print "Cluster representatives:\n";
#	foreach my $clus_rep (sort {scalar keys %{$clusters_representatives{$b}} <=> scalar keys %{$clusters_representatives{$a}}} keys %clusters_representatives) {
#		print "$clus_rep\t".(scalar keys %{$clusters_representatives{$clus_rep}});
#		foreach my $clus_del (keys %{$clusters_representatives{$clus_rep}}) {
#			print "\t$clus_del";
#		}
#		print "\n";
#	}
	# $clusters_overlap_info{5} = # clusters generated by all 5 methods, {CMC} = num clusters uniquely from CMC, etc, {CMC|HACO} = num overlap between CMC and HACO
	foreach my $clus_rep (keys %clusters_representatives) {
		if (scalar keys %{$clusters_representatives{$clus_rep}} == 0) {
			my $src = $$clusters_ref{$clus_rep}{SRC};
			$$clusters_overlap_info_ref{$src}++;
		}
		else {
			my %clus_srcs = ();
			foreach my $clus (keys %{$clusters_representatives{$clus_rep}}) {
				$clus_srcs{$$clusters_ref{$clus}{SRC}} = 1;
			}
			$clus_srcs{$$clusters_ref{$clus_rep}{SRC}} = 1;
			my $new_srcs = join('|', sort keys %clus_srcs);
			$$clusters_ref{$clus_rep}{SRC} = $new_srcs;
			my $num_srcs = scalar keys %clus_srcs;
			$$clusters_overlap_info_ref{$num_srcs}++;
		}
	}
	
	
	foreach my $clus (keys %clusters_to_delete) {
		delete $$clusters_ref{$clus};
	}	
}




sub CombineClusters($$$$$) {
	my $cmcclusters_ref = $_[0];
	my $c1clusters_ref = $_[1];
	my $ipcaclusters_ref = $_[2];
	my $mclclusters_ref = $_[3];
	my $rnscclusters_ref = $_[4];
	my $hacoclusters_ref = $_[5];
	my $coachclusters_ref = $_[6];
	my $combinedclusters_ref = $_[7];
#	print "In CombinemClusters, num cmc = ".(scalar keys %{$cmcclusters_ref}).", num ipca = ".(scalar keys %{$ipcaclusters_ref})."\n";
	foreach my $clus (keys %{$cmcclusters_ref}) {
		$$combinedclusters_ref{"$clus"}{SCORE} = $$cmcclusters_ref{$clus}{SCORE};
		$$combinedclusters_ref{"$clus"}{SRC} = $$cmcclusters_ref{$clus}{SRC};
		foreach my $prot (keys %{$$cmcclusters_ref{$clus}{ELEMENTS}}) {
			$$combinedclusters_ref{"$clus"}{ELEMENTS}{$prot} = 1;;
		}
	}
	foreach my $clus (keys %{$c1clusters_ref}) {
		$$combinedclusters_ref{"$clus"}{SCORE} = $$c1clusters_ref{$clus}{SCORE};
		$$combinedclusters_ref{"$clus"}{SRC} = $$c1clusters_ref{$clus}{SRC};
		foreach my $prot (keys %{$$c1clusters_ref{$clus}{ELEMENTS}}) {
			$$combinedclusters_ref{"$clus"}{ELEMENTS}{$prot} = 1;;
		}
	}
	foreach my $clus (keys %{$ipcaclusters_ref}) {
		$$combinedclusters_ref{"$clus"}{SCORE} = $$ipcaclusters_ref{$clus}{SCORE};
		$$combinedclusters_ref{"$clus"}{SRC} = $$ipcaclusters_ref{$clus}{SRC};
		foreach my $prot (keys %{$$ipcaclusters_ref{$clus}{ELEMENTS}}) {
			$$combinedclusters_ref{"$clus"}{ELEMENTS}{$prot} = 1;;
		}
	}
	foreach my $clus (keys %{$mclclusters_ref}) {
		$$combinedclusters_ref{"$clus"}{SCORE} = $$mclclusters_ref{$clus}{SCORE};
		$$combinedclusters_ref{"$clus"}{SRC} = $$mclclusters_ref{$clus}{SRC};
		foreach my $prot (keys %{$$mclclusters_ref{$clus}{ELEMENTS}}) {
			$$combinedclusters_ref{"$clus"}{ELEMENTS}{$prot} = 1;;
		}
	}
	foreach my $clus (keys %{$rnscclusters_ref}) {
		$$combinedclusters_ref{"$clus"}{SCORE} = $$rnscclusters_ref{$clus}{SCORE};
		$$combinedclusters_ref{"$clus"}{SRC} = $$rnscclusters_ref{$clus}{SRC};
		foreach my $prot (keys %{$$rnscclusters_ref{$clus}{ELEMENTS}}) {
			$$combinedclusters_ref{"$clus"}{ELEMENTS}{$prot} = 1;;
		}
	}
	foreach my $clus (keys %{$hacoclusters_ref}) {
		$$combinedclusters_ref{"$clus"}{SCORE} = $$hacoclusters_ref{$clus}{SCORE};
		$$combinedclusters_ref{"$clus"}{SRC} = $$hacoclusters_ref{$clus}{SRC};
		foreach my $prot (keys %{$$hacoclusters_ref{$clus}{ELEMENTS}}) {
			$$combinedclusters_ref{"$clus"}{ELEMENTS}{$prot} = 1;;
		}
	}
	foreach my $clus (keys %{$coachclusters_ref}) {
		$$combinedclusters_ref{"$clus"}{SCORE} = $$coachclusters_ref{$clus}{SCORE};
		$$combinedclusters_ref{"$clus"}{SRC} = $$coachclusters_ref{$clus}{SRC};
		foreach my $prot (keys %{$$coachclusters_ref{$clus}{ELEMENTS}}) {
			$$combinedclusters_ref{"$clus"}{ELEMENTS}{$prot} = 1;;
		}
	}
#	print "num combined = ".(scalar keys %{$combinedclusters_ref})."\n";
}


#sub FindIntersection {
#	my $clusters1ref = $_[0];
#	my $clusters2ref = $_[1];
#	my $matchscore_thr = $_[2];
#	my $intersectionref = $_[3];
#	
#	my $num_score_exceeded = 0;
#	foreach my $clus1 (keys %{$clusters1ref}) {
#		foreach my $clus2 (keys %{$clusters2ref}) {
#			my $score = MatchClusters($$clusters1ref{$clus1}{ELEMENTS}, $$clusters2ref{$clus2}{ELEMENTS});
#			
#			if ($score >= $matchscore_thr) {
#				$$intersectionref{INTS}{$clus1}{SCORE} = $$clusters1ref{$clus1}{SCORE};
#				foreach my $prot (keys %{$$clusters1ref{$clus1}{ELEMENTS}}) {
#					$$intersectionref{INTS}{$clus1}{ELEMENTS}{$prot} = 1;
#				}
#				$$intersectionref{INTS}{$clus2}{SCORE} = $$clusters2ref{$clus2}{SCORE};
#				foreach my $prot (keys %{$$clusters2ref{$clus2}{ELEMENTS}}) {
#					$$intersectionref{INTS}{$clus2}{ELEMENTS}{$prot} = 1;
#				}
#			}
#		}
#	}
#	$$intersectionref{JAC} = (scalar keys %{$$intersectionref{INTS}}) / ((scalar keys %{$clusters1ref}) + (scalar keys %{$clusters2ref}));
#}


